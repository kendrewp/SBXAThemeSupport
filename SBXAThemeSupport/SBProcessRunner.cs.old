using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Threading;
using System.Windows;
using System.Windows.Threading;
using SBXA.Runtime;
using System.Linq;
using SBXA.Shared;
using SBXA.Shared.Definitions;
using SBXA.UI.Client;
using SBXA.UI.WPFControls;

namespace SBXAThemeSupport
{
    public class SBProcessRunner
    {
        #region Delegates

        public delegate void SBPlusProcess(object parameter, string currentFormHandle, IInputElement target, bool isInContext, ServerProcessFailed serverProcessFailed = null);

        #endregion

        private static readonly SBProcessRunner _ProcessRunner = new SBProcessRunner();

        private bool _IsRunningProcesses;
        private readonly ConcurrentQueue<IActionDefinition> _Processes = new ConcurrentQueue<IActionDefinition>();
        private readonly object _RunProcessLock = new object();

        private SBProcessRunner()
        {
            SBPlusRuntime.Current.CommandProcessor.IsServerWaitingChanged += IsServerWaitingChanged;
            SBPlusRuntime.Current.DisConnected += SBPlusDisconnected;
        }

        private void SBPlusDisconnected(object sender, EventArgs args)
        {
            SBPlusRuntime.Current.CommandProcessor.IsServerWaitingChanged -= IsServerWaitingChanged;
            SBPlusClient.Connected += SBPlusClientOnConnected;
        }

        private void SBPlusClientOnConnected(object sender, EventArgs eventArgs)
        {
            SBPlusRuntime.Current.CommandProcessor.IsServerWaitingChanged += IsServerWaitingChanged;
        }

        private void IsServerWaitingChanged(object sender, EventArgs args)
        {
            RunProcess();
        }

        public static SBProcessRunner Instance
        {
            get { return _ProcessRunner; }
        }

        public bool HasJobsToProcess
        {
            get { return _Processes.Count > 0; }
        }

        public int Count()
        {
            return _Processes.Count;
        }

        public int Count(string name)
        {
            return _Processes.ToArray().Cast<ActionDefinition>().Count(a => a.Name == name);
        }

        public int Count(Func<SBProcessDefinition, bool> predicate)
        {
            return
// ReSharper disable SuspiciousTypeConversion.Global
// ReSharper disable ConditionIsAlwaysTrueOrFalse
                _Processes.ToArray().Where(o => o is SBProcessDefinition).Cast<SBProcessDefinition>().Where(predicate).Count();
// ReSharper restore ConditionIsAlwaysTrueOrFalse
// ReSharper restore SuspiciousTypeConversion.Global
        }

        private void RunProcess()
        {
            if (Application.Current.Dispatcher.CheckAccess())
            {
                JobManager.RunAsyncOnPooledThread(state => DoRunProcess());
            }
            else
            {
                DoRunProcess();
            }
        }

        private void DoRunProcess()
        {
            if (_IsRunningProcesses) return;
            _IsRunningProcesses = true;
            try
            {

                while (_Processes.Count > 0 && IsServerReady)
                {
                    SBPlusClient.LogInformation(string.Format("Jobs to process {0}", _Processes.Count));

                    IActionDefinition targetAction;
                    if (!_Processes.TryPeek(out targetAction)) break; // if there is nothing in the queue break out.
                    
                    // In theory, the value on CanSendCommandToServer can change between the check and the call.
                    if (!targetAction.CanSendCommandToServer()) break; // Nothing can be sent to the server so break out.

                        try
                        {
                            if (targetAction is ActionDefinition)
                            {
                                SBPlusClient.LogInformation("Executing action. Is on UI thread " + Application.Current.Dispatcher.CheckAccess());

                                ((ActionDefinition)targetAction).Action.Invoke();
                                _Processes.TryDequeue(out targetAction); // Only remove the process from the queue if it runs sucessfully.

                                SBPlusClient.LogInformation("Executed action. Number of processes left = " + _Processes.Count);
                            }
                            else
                            {
                                // If the action is only to run a process on the server, then inclose the check and the call in a single block so as to prevent any action on the UI from getting in between and preventing 
                                // the server call.
                                JobManager.RunSyncInUIThread(DispatcherPriority.Normal,
                                                             () =>
                                                                 {
                                                                     if (!CanSendServerCommands) return;
                                                                     try
                                                                     {
                                                                         SBPlusClient.LogInformation("Executing action. Is on UI thread " + Application.Current.Dispatcher.CheckAccess());

                                                                         ((SBProcessCallAction)targetAction).Action.Invoke(((SBProcessCallAction)targetAction).ProcessName);
                                                                         _Processes.TryDequeue(out targetAction); // Only remove the process from the queue if it runs sucessfully.

                                                                         SBPlusClient.LogInformation("Executed action. Number of processes left = " + _Processes.Count);
                                                                     }
                                                                     catch (Exception exception)
                                                                     {
                                                                         SBPlusClient.LogError("Exception while executing SB+ process.", exception);
                                                                     }
                                                                 });
                            }
                            SBPlusClient.LogInformation("Executed action");
                        }
                        catch (SBPlusApplicationException exception)
                        {
                            Debug.WriteLine("[SBProcessRunner.RunProcess(186)] Exception " + exception.Message);
                            if (!IsServerReady ||
                                exception.Message.Contains("The server is currently busy and cannot accept requests."))
                            {
                                if (IsServerReady)
                                {
                                    // this can cause executing of the action in wrong order, but should never be executed
                                    // do not use above peek because the Invoke of the action could cause the process runner to run again
                                    SBPlusClient.LogError(
                                        string.Format("Exception is caught. Server is waiting: {0}",
                                                      SBPlusRuntime.Current.CommandProcessor.IsServerWaiting), exception);
                                    Thread.Sleep(300);
                                    Extensions.DoEvents();
                                    Dispatcher.CurrentDispatcher.BeginInvoke(DispatcherPriority.Background,
                                                                             new Action(RunProcess));
                                    return;
                                }
                            }
                            else
                            {
                                SBPlusClient.LogError(
                                    string.Format("Exception is caught. Server is waiting: {0}",
                                                  SBPlusRuntime.Current.CommandProcessor.IsServerWaiting), exception);
                                throw;
                            }
                        }
                        catch (Exception exception)
                        {
                            SBPlusClient.LogError(
                                string.Format("Exception is caught. Server is waiting: {0}",
                                              SBPlusRuntime.Current.CommandProcessor.IsServerWaiting), exception);
                            throw;
                        }
                    
                    
                }
            }
            finally
            {

                _IsRunningProcesses = false;
            }
        }

        public void ExecuteMethod(Action myAction, string name)
        {
            ExecuteMethod(myAction, false, name);
        }

        public void ExecuteMethod(Action myAction, bool canCauseUnexpectedResponsesToServer, string name = null)
        {
            var actionDefinition = new ActionDefinition(canCauseUnexpectedResponsesToServer, myAction);
            Debug.WriteLine("[SBProcessRunner.ExecuteMethod(196)] adding process ");
            _Processes.Enqueue(actionDefinition);
            RunProcess();
            
        }

        /// <summary>
        /// Executes a process via an Action.
        /// </summary>
        /// <param name="myAction"></param>
        /// <example>
        /// <code lang="c#"> 
        /// ...
        /// ...
        /// ...
        /// SbProcessRunner.Instance.ExecuteMethod(() => InitializeStartguiInternal(options));
        /// ...
        /// ...
        /// ...
        /// </code>
        /// </example>
        public void ExecuteMethod(Action myAction)
        {
            ExecuteMethod(myAction, false);
        }

        public void ExecuteSBPlusProcess(SBPlusProcess sbPlusProcess, bool isInContext, object parameter, IInputElement target, ServerProcessFailed serverProcessFailed, string name = null)
        {
                var processDefinition = new SBProcessDefinition
                                            {
                                                SbProcess = sbPlusProcess,
                                                IsInContext = isInContext,
                                                Parameter = parameter,
                                                Target = target,
                                                CurrentFormSbHandle = CurrentFormSBHandle,
                                                ServerProcessFailedCallback = serverProcessFailed,
                                                Name = name
                                            };

// change this one.                _Processes.Enqueue(processDefinition.SbProcess);
                RunProcess();
        }

        /// <summary>
        /// Executes a process on the server asynchronously.
        /// </summary>
        /// <param name="processName">The name of the process to call.</param>
        /// <example>
        /// <code lang="c#">
        /// ...
        /// ...
        /// ...
        /// SBProcessRunner.Instance.ExecuteSBPlusProcess(processCall);
        /// ...
        /// ...
        /// ...
        /// </code>
        /// </example>
        public void ExecuteSBPlusProcess(string processName)
        {
            var actionDefinition = new SBProcessCallAction(processName, true, ExecuteSBProcess);
            _Processes.Enqueue(actionDefinition);
            RunProcess();
        }

        private static void ExecuteSBProcess(string processName)
        {
            Debug.WriteLine("[SBProcessRunner.RunDummyProcess(224)] Executing " + processName);
            SBPlusRuntime.Current.ExecuteServerProcess(processName, ServerProcessFailed);
            Debug.WriteLine("[SBProcessRunner.RunDummyProcess(226)] Executed " + processName);
        }

        public static bool IsServerReady
        {

            get
            {
                bool isReady = false;
                if (Application.Current.Dispatcher.CheckAccess())
                {
                    return CheckIsServerReady();
                }
                JobManager.RunSyncInUIThread(DispatcherPriority.Input, () => { isReady = CheckIsServerReady(); });

                return isReady;
            }
        }

        public static bool CanSendServerCommands
        {

            get
            {
                bool isReady = false;
                if (Application.Current.Dispatcher.CheckAccess())
                {
                    return CheckCanSendServerCommands();
                }
                JobManager.RunSyncInUIThread(DispatcherPriority.Input, () => { isReady = CheckCanSendServerCommands(); });

                return isReady;
            }
        }

        public static bool IsSBDialogBoxOpen
        {
            get
            {
                bool isSbDialogBoxOpen = false;
                if (Application.Current.Dispatcher.CheckAccess())
                {
                    return CheckIfDialogIsOpen();
                }
                JobManager.RunSyncInUIThread(DispatcherPriority.Input, () => { isSbDialogBoxOpen = CheckIfDialogIsOpen(); });

                return isSbDialogBoxOpen;
            }
        }

        public static bool CheckIfDialogIsOpen()
        {
            if (SBPlus.Current == null || SBPlus.Current.CurrentForm == null) return false;
            return SBPlus.Current.CurrentForm is SBDialog;
        }

        private static bool CheckCanSendServerCommands()
        {
            
            SBPlusClient.LogInformation(string.Format("IsServerWaiting: {0} CanSendServerCommands: {1}", SBPlusRuntime.Current.CommandProcessor.IsServerWaiting, SBPlusClient.Current.CanSendServerCommands));

            return SBPlusClient.Current.CanSendServerCommands;
        }

        private static bool CheckIsServerReady()
        {
            if (SBPlus.Current == null || SBPlus.Current.ConnectionStatus != ConnectionStatuses.Connected || String.IsNullOrEmpty(SBPlus.Current.CurrentAccountName) || String.IsNullOrEmpty(SBPlus.Current.CurrentSystemId)) return false;

            SBPlusClient.LogInformation(string.Format("IsServerWaiting: {0} CanSendServerCommands: {1}", SBPlusRuntime.Current.CommandProcessor.IsServerWaiting, SBPlusClient.Current.CanSendServerCommands));
            Debug.WriteLine("[SBProcessRunner.CheckIsServerReady(329)] " + string.Format("IsServerWaiting: {0} CanSendServerCommands: {1}", SBPlusRuntime.Current.CommandProcessor.IsServerWaiting, SBPlusClient.Current.CanSendServerCommands));
            return SBPlusRuntime.Current.CommandProcessor.IsServerWaiting;
        }

        public static bool HasServerPendingJobsToProcess
        {
            get { return Instance.HasJobsToProcess || !IsServerReady; }
        }

        public static bool HasServerPendingJobsToProcessOnlyWithName(string name)
        {
            int countWithName = Instance.Count(j => j.Name == name);
            int totalCount = Instance.Count();
            return countWithName == totalCount;
        }

        public static string CurrentFormSBHandle
        {
            get
            {
                if (SBPlus.Current != null && SBPlus.Current.CurrentForm != null)
                {
                    return SBFocusManager.FormWithFocus.SBObjectHandle;
                }
                return String.Empty;
            }
        }

        public static void CallProcess(string processName, bool isInContext, SBString parameter, string name = null)
        {
            string param = parameter != null ? parameter.GetRawString() : string.Empty;


            string procIncludingParam = processName;
            if (!string.IsNullOrEmpty(param)) procIncludingParam = string.Format("{0},{1}", processName, param);

            SBPlusClient.LogInformation(string.Format("CheckIsServerReady: {0}, process call: {1}", IsServerReady, procIncludingParam));

            Instance.ExecuteSBPlusProcess(CallProcessInternal, isInContext, procIncludingParam, SBPlus.Current, null, name);
        }

        public static void CallProcess(string processName, bool isInContext, SBString parameter, ServerProcessFailed serverProcessFailed, string name = null)
        {
            string param = parameter.GetRawString();

            SBPlusClient.LogInformation(string.Format("Check Application.IsServerReady: {0}", IsServerReady));

            string procIncludingParam = processName;
            if (!string.IsNullOrEmpty(param)) procIncludingParam = string.Format("{0},{1}", processName, param);

            Instance.ExecuteSBPlusProcess(CallProcessInternal, isInContext,
                                                          procIncludingParam,
                                                          SBPlus.Current,
                                                          serverProcessFailed,
                                                          name);
        }

        private static void CallProcessInternal(object parameter, string currentFormHandle, IInputElement target, bool isInContext, ServerProcessFailed serverProcessFailed = null)
        {
            if (parameter == null)
            {
                SBPlusClient.LogInformation("parameter is null. This should never be the case");
                return;
            }

            string myLogParameter = parameter.ToString();

            // if the current form is no longer the current from so ignore the call
            if (isInContext && CurrentFormSBHandle != currentFormHandle)
            {
                SBPlusClient.LogWarning(string.Format("Ignore the call before the form is no longer the current form. Parameter: {0}", myLogParameter));
                SBPlusClient.LogWarning("Ignore the call before the form is no longer the current form.");
                return;
            }

            // change the incontext);
            if (isInContext && SBPlus.Current != null && SBPlus.Current.CurrentForm != null)
            {
                GuiObjectDefinition guiObjectDefinition;
                if (SBFocusManager.FormWithFocus is SBMultiForm)
                {
                    guiObjectDefinition = ((SBForm)((SBMultiForm)SBFocusManager.FormWithFocus).CurrentForm).GuiObjectDefinition;
                }
                else
                {
                    guiObjectDefinition = SBFocusManager.FormWithFocus.GuiObjectDefinition;
                }

                var formObjectDefinition = guiObjectDefinition as FormObjectDefinition;
                isInContext = formObjectDefinition != null && formObjectDefinition.ProcessType == ProcessTypes.I;
            }

            SBPlusClient.LogInformation(string.Format("CallProcessInternal isInContext: {0} Parameter: {1}", isInContext, myLogParameter));

            SBPlusClient.LogInformation(string.Format("Der Process : {0} wird aufgerufen.", myLogParameter));

            if (isInContext)
            {
                SBPlusRuntime.Current.ExecuteInContextServerProcess(myLogParameter, serverProcessFailed ?? ServerProcessFailed);
            }
            else
            {
                SBPlusRuntime.Current.ExecuteServerProcess(myLogParameter, serverProcessFailed ?? ServerProcessFailed);
            }

            SBPlusClient.LogInformation(string.Format("Der Process : {0} wurde aufgerufen.", myLogParameter));
        }

        private static void ServerProcessFailed(string processName, object stateObject, Exception exception)
        {
            Debug.WriteLine("[SBProcessRunner.ServerProcessFailed(37)] Failed to execute " + processName);
        }


        /// <summary>
        /// This method will execute a subroutine on the server synchronously. If the server is busy, then based on the ignore if busy flag will either ignore the call or throw an exception.
        /// </summary>
        /// <param name="subroutineName">The name of the subroutine</param>
        /// <param name="parCount">The numbr of parameters</param>
        /// <param name="parameter">The actual parameters being passed to the subroutine</param>
        /// <param name="ignoreIfBusy">If this is true, then the subroutine call will be ignored if the server is busy. If not then an exception will be thrown if the server is busy.</param>
        /// <param name="onlyServerSide">If this is true it means that the basic subroutine will not do anything to cause the server to make a call to the client and therefore we do not have to worry about checking if the UI is busy.</param>
        /// <returns>The values that were passed back from the subroutine.</returns>
        public static SBString[] CallSubroutine(string subroutineName, int parCount, SBString[] parameter, bool ignoreIfBusy = true, bool onlyServerSide = false)
        {
            if (subroutineName == null) throw new ArgumentNullException("subroutineName");

            if (parameter.Length < parCount)
            {
                Array.Resize(ref parameter, parCount);
            }

            if (!ignoreIfBusy && !IsServerReady)
            {
                throw new Exception("The server is not able to accept requests at this time.");
            }

            if (!ignoreIfBusy && !CanSendServerCommands)
            {
                throw new Exception("The server is not able to accept requests at this time.");
            }

            SBString[] retunSBStrings = null;
            if (Application.Current.Dispatcher.CheckAccess())
            {
                retunSBStrings = onlyServerSide ? ExecuteSubroutineIfNoUi(subroutineName, parameter) : ExecuteSubroutine(subroutineName, parameter);
            }
            else
            {
                if (onlyServerSide)
                {
                    JobManager.RunSyncInUIThread(DispatcherPriority.Normal, () => retunSBStrings = ExecuteSubroutineIfNoUi(subroutineName, parameter));
                }
                else
                {
                    JobManager.RunSyncInUIThread(DispatcherPriority.Normal, () => retunSBStrings = ExecuteSubroutine(subroutineName, parameter));
                }
            }
            return retunSBStrings;
        }

        private static SBString[] ExecuteSubroutine(string subroutineName, SBString[] arguments)
        {
            SBString[] retunSBStrings = null;

            Debug.WriteLine("[SbProcessHandler.ExecuteSubroutine(204)] " + SBPlusClient.Current.CanSendServerCommands + ", " + SBPlusRuntime.Current.CommandProcessor.IsServerWaiting);

            if (SBPlusClient.Current.CanSendServerCommands && SBPlusRuntime.Current.CommandProcessor.IsServerWaiting)
            {
                try
                {
                    retunSBStrings = SBPlusClient.Current.ExecuteSubroutineSynchronous(subroutineName, arguments);
                }
                catch (Exception exception)
                {
                    Debug.WriteLine("[SbProcessHandler.CallSubroutine(174)] Exception calling subroutine " + exception.Message);
                }
            }
            else
            {
                Debug.WriteLine("[SbProcessHandler.CallSubroutine(181)] skipped call because server was not ready.");
            }
            return retunSBStrings;
        }

        private static SBString[] ExecuteSubroutineIfNoUi(string subroutineName, SBString[] arguments)
        {
            SBString[] retunSBStrings = null;

            Debug.WriteLine("[SbProcessHandler.ExecuteSubroutine(204)] " + SBPlusRuntime.Current.CommandProcessor.IsServerWaiting);

            if (SBPlusRuntime.Current.CommandProcessor.IsServerWaiting)
            {
                try
                {
                    retunSBStrings = SBPlusClient.Current.ExecuteSubroutineSynchronous(subroutineName, arguments);
                }
                catch (Exception exception)
                {
                    Debug.WriteLine("[SbProcessHandler.CallSubroutine(174)] Exception calling subroutine " + exception.Message);
                }
            }
            else
            {
                Debug.WriteLine("[SbProcessHandler.CallSubroutine(181)] skipped call because server was not ready.");
            }
            return retunSBStrings;
        }

        /// <summary>
        /// Executes a subroutine on the server asynchronously.
        /// </summary>
        /// <param name="callback"></param>
        /// <param name="subroutineName"></param>
        /// <param name="parCount"></param>
        /// <param name="parameter"></param>
        /// <example>
        /// <code lang="C#">
        /// ...
        /// ...
        /// ...
        ///    SBProcessRunner.CallSubroutine((b, r) => DoRefreshWidget(b, r), WIDGET_REFRESH_PARA, 1, widgetKey);
        /// }
        ///
        /// private static void DoRefreshWidget(bool isOk, SBString[] result)
        /// {
        ///     Debug.WriteLine("[DashBoardConfiguration.DoRefreshWidget(277)] " + isOk);
        /// }
        /// </code>
        /// </example>
        public static void CallSubroutine(Action<bool, SBString[]> callback, string subroutineName, int parCount, params string[] parameter)
        {
            var sbString = PrepareSubroutineParam(parCount, parameter);
            SBProcessRunner.Instance.ExecuteMethod(() => SubroutineCallback(subroutineName, sbString, callback));
        }
        private static void SubroutineCallback(string subroutinename, SBString[] parameters, Action<bool, SBString[]> callback)
        {
            var callbackRuntime = new CallbackRuntime<bool, SBString[]>();
            callbackRuntime.Callback = callback;
            SBPlusClient.Current.ExecuteSubroutine(subroutinename, parameters, callbackRuntime, SubroutineOkCallback, SubroutineFailedCallback);
        
        }

        private static void SubroutineFailedCallback(string subroutinename, SBString[] parameters, object userstate, Exception exception)
        {
            ExecuteSubroutineCallback(false, parameters, userstate);
        }

        private static void ExecuteSubroutineCallback(bool isOk, SBString[] parameters, object userstate)
        {
            var callbackRuntime = userstate as CallbackRuntime<bool, SBString[]>;
            if (callbackRuntime == null) return;
            callbackRuntime.Callback(isOk, parameters);
        }

        private static void SubroutineOkCallback(string subroutinename, SBString[] parameters, object userstate)
        {
            Debug.WriteLine("[SBProcessRunner.SubroutineOkCallback(596)] " + IsServerReady);
            ExecuteSubroutineCallback(true, parameters, userstate);
        }

        private static SBString[] PrepareSubroutineParam(int parCount, string[] parameter)
        {
            var sbString = new SBString[parCount];
            for (int i = 0; i < parCount; i++)
            {
                if (i < parameter.Length)
                {
                    sbString[i] = new SBString(parameter[i]);
                }
                else
                {
                    sbString[i] = new SBString();
                }
            }

            return sbString;
        }


        #region Nested type: SBProcessDefinition

        public class SBProcessDefinition
        {
            public SBPlusProcess SbProcess { get; set; }
            public object Parameter { get; set; }
            public IInputElement Target { get; set; }
            public bool IsInContext { get; set; }
            public string CurrentFormSbHandle { get; set; }
            public string Name { get; set; }
            public ServerProcessFailed ServerProcessFailedCallback { get; set; }
        }

        #endregion

        #region Nested class ActionDefinition

        public interface IActionDefinition
        {
            string Name { get;  }
            Func<bool> CanSendCommandToServer { get;  }
        }

        public class ActionDefinition : IActionDefinition
        {
            public ActionDefinition(bool canCauseUnexpectedResponses, Action actionToRun, string name)
            {
                Name = name;
                if (actionToRun == null) throw new ArgumentNullException("actionToRun");
                if (canCauseUnexpectedResponses)
                {
                    CanSendCommandToServer = () => SBPlusClient.Current.CanSendServerCommands;
                }
                else
                {
                    CanSendCommandToServer = () => IsServerReady;
                }
                Action = actionToRun;

            }

            public ActionDefinition(bool canCauseUnexpectedResponsesToServer, Action actionToRun) :this(canCauseUnexpectedResponsesToServer, actionToRun, string.Empty)
            {
            }

            public string Name { get; private set; }
            public Func<bool> CanSendCommandToServer { get; private set; }
            public Action Action { get; private set; }
        }

        private class SBProcessCallAction : IActionDefinition
        {
            private SBProcessCallAction(string processName, bool canCauseUnexpectedResponses, Action<string> actionToRun, string name)
            {
                ProcessName = processName;
                Name = name;
                if (actionToRun == null) throw new ArgumentNullException("actionToRun");
                if (canCauseUnexpectedResponses)
                {
                    CanSendCommandToServer = () => CanSendServerCommands;
                }
                else
                {
                    CanSendCommandToServer = () => IsServerReady;
                }
                Action = actionToRun;

            }

            public SBProcessCallAction(string processName, bool canCauseUnexpectedResponsesToServer, Action<string> actionToRun)
                : this(processName, canCauseUnexpectedResponsesToServer, actionToRun, string.Empty)
            {
            }

            public string ProcessName { get; private set; }
            public string Name { get; private set; }
            public Func<bool> CanSendCommandToServer { get; private set; }
            public Action<string> Action { get; private set; }
        }

        #endregion Nested class

        private class CallbackRuntime<T, T2>
        {
            public CallbackRuntime()
            {
                this.Identification = Guid.NewGuid();
            }

            internal Guid Identification
            {
                get;
                private set;
            }

            internal Action<T, T2> Callback
            {
                get;
                set;
            }
            internal SBString Data
            {
                get;
                set;
            }
        }

    }


}